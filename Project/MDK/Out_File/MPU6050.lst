C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE MPU6050
OBJECT MODULE PLACED IN .\Out_File\MPU6050.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\CODE\MPU6050.c XSMALL INTR2 WARNINGLEVEL(3) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\MPU6050.lst) OBJECT(.\Out_File\MPU6050.obj) 

stmt  level    source

    1          #include "math.h"
    2          #include "MPU6050.h"
    3          #include <intrins.h>
    4          
    5          float Pitch=0, Roll=0, Yaw=0,x1=0,y1=0,z1=0;
    6          
    7          #define I2C_TIMEOUT_TIMES 100   //超时倍数
    8          
    9          //延时 用于等待应答时的超时判断 移植时需修改
   10          void i2c_timeout_delay(void)    
   11          {
   12   1              char i;
   13   1              i =7;
   14   1              while (--i);
   15   1      }
   16          
   17          void i2c_delay()        //每步的间隔 用于等待电平稳定和控制通讯速率
   18          {
   19   1              char i;
   20   1              i =7;
   21   1              while (--i);
   22   1      }
   23          
   24          //SCL拉高 移植时需修改
   25          void I2C_SCL_H(void)
   26          {
   27   1              I2C_SCL = 1;
   28   1      }
   29          
   30          //SCL拉低 移植时需修改
   31          void I2C_SCL_L(void)
   32          {
   33   1              I2C_SCL = 0;
   34   1      }
   35          
   36          //SDA拉高 移植时需修改
   37          void I2C_SDA_H(void)
   38          {
   39   1              I2C_SDA = 1;
   40   1      }
   41          
   42          //SDA拉低 移植时需修改
   43          void I2C_SDA_L(void)
   44          {
   45   1              I2C_SDA = 0;
   46   1      }
   47          
   48          //读取SDA 移植时需修改
   49          uint8 I2C_SDA_Read(void)
   50          {
   51   1              return I2C_SDA;
   52   1      }
   53          
   54          /*******************************************************************************
   55          * 函 数 名       : i2c_start
   56          * 函数功能               : 产生I2C起始信号
   57          * 输    入       : 无
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 2   

   58          * 输    出       : 无
   59          *******************************************************************************/
   60          void i2c_start(void)
   61          {
   62   1              I2C_SDA_H();
   63   1          I2C_SCL_H();
   64   1          i2c_delay();
   65   1      
   66   1          I2C_SDA_L();        //当SCL为高电平时，SDA由高变为低
   67   1          i2c_delay();
   68   1          I2C_SCL_L();        //钳住I2C总线，准备发送或接收数据
   69   1      }
   70          
   71          /*******************************************************************************
   72          * 函 数 名         : i2c_stop
   73          * 函数功能                 : 产生I2C停止信号
   74          * 输    入         : 无
   75          * 输    出         : 无
   76          *******************************************************************************/
   77          void i2c_stop(void)
   78          {
   79   1              I2C_SDA_L();
   80   1          I2C_SCL_H();
   81   1          i2c_delay();
   82   1      
   83   1          I2C_SDA_H();        //当SCL为高电平时，SDA由低变为高
   84   1          i2c_delay();
   85   1      }
   86          
   87          /*******************************************************************************
   88          * 函 数 名         : i2c_ack
   89          * 函数功能                 : 产生ACK应答
   90          * 输    入         : 无
   91          * 输    出         : 无
   92          *******************************************************************************/
   93          void i2c_ack(void)
   94          {
   95   1          I2C_SCL_L();
   96   1          I2C_SDA_L();        //SDA为低电平
   97   1          i2c_delay();
   98   1      
   99   1          I2C_SCL_H();
  100   1          i2c_delay();
  101   1          I2C_SCL_L();
  102   1              I2C_SDA_H();    
  103   1      }
  104          
  105          /*******************************************************************************
  106          * 函 数 名         : i2c_nack
  107          * 函数功能                 : 产生NACK非应答
  108          * 输    入         : 无
  109          * 输    出         : 无
  110          *******************************************************************************/
  111          void i2c_nack(void)
  112          {
  113   1          I2C_SCL_L();
  114   1          I2C_SDA_H();        //SDA为高电平
  115   1          i2c_delay();
  116   1      
  117   1          I2C_SCL_H();
  118   1          i2c_delay();
  119   1          I2C_SCL_L();
  120   1      }
  121          
  122          /*******************************************************************************
  123          * 函 数 名         : i2c_wait_ack
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 3   

  124          * 函数功能                 : 等待应答信号到来
  125          * 输    入         : 无
  126          * 输    出         : 1，接收应答失败
  127                                           0，接收应答成功
  128          *******************************************************************************/
  129          uint8 i2c_wait_ack(void)
  130          {
  131   1          uint16 time_temp = 0;
  132   1      
  133   1          I2C_SCL_H();
  134   1          i2c_delay();
  135   1          while(I2C_SDA_Read())                               //等待SDA为低电平
  136   1          {
  137   2              time_temp++;
  138   2                      i2c_timeout_delay();
  139   2              if(time_temp > I2C_TIMEOUT_TIMES)       //超时则强制结束I2C通信
  140   2              {
  141   3                  i2c_stop();
  142   3                  return 1;
  143   3              }
  144   2          }
  145   1          I2C_SCL_L();
  146   1          return 0;
  147   1      }
  148          
  149          /*******************************************************************************
  150          * 函 数 名         : i2c_write_byte
  151          * 函数功能                 : I2C发送一个字节
  152          * 输    入         : dat：发送一个字节
  153          * 输    出         : 无
  154          *******************************************************************************/
  155          void i2c_write_byte(uint8 dat)
  156          {
  157   1          uint8 i = 0;
  158   1      
  159   1          I2C_SCL_L();
  160   1          for(i = 0; i<8; i++)        //循环8次将一个字节传出，先传高再传低位
  161   1          {
  162   2              if((dat & 0x80) > 0)
  163   2                  I2C_SDA_H();
  164   2              else
  165   2                  I2C_SDA_L();
  166   2              dat <<= 1;
  167   2              i2c_delay();
  168   2              I2C_SCL_H();
  169   2              i2c_delay();
  170   2              I2C_SCL_L();
  171   2              i2c_delay();
  172   2          }
  173   1      }
  174          
  175          /*******************************************************************************
  176          * 函 数 名         : i2c_read_byte
  177          * 函数功能                 : I2C读一个字节
  178          * 输    入         : ack = 1时，发送ACK，ack = 0，发送nACK
  179          * 输    出         : 应答或非应答
  180          *******************************************************************************/
  181          uint8 i2c_read_byte(uint8 ack)
  182          {
  183   1          uint8 i = 0, receive = 0;
  184   1      
  185   1          for(i = 0; i < 8; i++ )     //循环8次将一个字节读出，先读高再传低位
  186   1          {
  187   2              I2C_SCL_L();
  188   2              i2c_delay();
  189   2              I2C_SCL_H();
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 4   

  190   2              receive <<= 1;
  191   2              if(I2C_SDA_Read())
  192   2                              receive++;
  193   2              i2c_delay();
  194   2          }
  195   1          if (!ack)
  196   1              i2c_nack();
  197   1          else
  198   1              i2c_ack();
  199   1      
  200   1          return receive;
  201   1      }
  202          
  203          /*******************************************************************************
  204          * 函 数 名         : i2c_mem_write
  205          * 函数功能                 : I2C对指定器件、指定寄存器连续写入
  206          * 输    入         : 器件地址、器件寄存器地址、待输入数据首地址、待输入数据长度
  207          * 输    出         : 0: 成功 1：失败
  208          *******************************************************************************/
  209          uint8 i2c_mem_write(uint8 DevAddress, uint8 MemAddress, uint8 *pData, uint16 Len)
  210          {
  211   1              i2c_start();
  212   1              i2c_write_byte(DevAddress << 1);
  213   1              if(i2c_wait_ack())
  214   1                      return 1;
  215   1              i2c_write_byte(MemAddress);
  216   1              if(i2c_wait_ack())
  217   1                      return 1;
  218   1              while(Len--)
  219   1              {
  220   2                      i2c_write_byte(*pData++);
  221   2                      if(i2c_wait_ack())
  222   2                              return 1;
  223   2              }
  224   1              i2c_stop();
  225   1              return 0;
  226   1      }
  227          
  228          /*******************************************************************************
  229          * 函 数 名         : i2c_mem_read
  230          * 函数功能                 : I2C对指定器件、指定寄存器连续读取
  231          * 输    入         : 器件地址、器件寄存器地址、数据缓冲区首地址、数据长度
  232          * 输    出         : 0: 成功 1：失败
  233          *******************************************************************************/
  234          uint8 i2c_mem_read(uint8 DevAddress, uint8 MemAddress, uint8 *pBuffer, uint16 Len)
  235          {                                 
  236   1          i2c_start();  
  237   1              i2c_write_byte(DevAddress << 1);                //发送写命令       
  238   1              if(i2c_wait_ack())
  239   1                      return 1;
  240   1          i2c_write_byte(MemAddress);                         //发送字地址  
  241   1              if(i2c_wait_ack())
  242   1                      return 1;   
  243   1              i2c_start();               
  244   1              i2c_write_byte(DevAddress << 1 | 1);    //进入接收模式                             
  245   1              if(i2c_wait_ack())
  246   1                      return 1;
  247   1              while(Len--)
  248   1              {
  249   2                      *pBuffer++ = i2c_read_byte(Len!=0);     //读取字节      
  250   2              }
  251   1          i2c_stop();                                                         //产生一个停止条件  
  252   1              return 0;
  253   1      }
  254          
  255          /**写入8位寄存器的一个位。
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 5   

  256          * @参数 DevAddress      I2C从器件地址
  257          * @参数 addr            I2C从器件内部地址
  258          * @参数 bitNum          写入的比特位(0-7)
  259          * @参数 data            写入数据
  260          * @返回值 返回状态 (0=成功)
  261          */
  262          uint8 i2c_write_bit(uint8 DevAddress, uint8 addr, uint8 bitNum, uint8 Data)
  263          {
  264   1              uint8 b;
  265   1              if (!i2c_mem_read(DevAddress, addr, &b, 1))
  266   1              {
  267   2                      b = (Data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
  268   2                      return i2c_mem_write(DevAddress, addr, &b, 1);  //写入数据
  269   2              }
  270   1              else
  271   1                      return 1;
  272   1      }
  273          
  274          /**写入8位寄存器的多个位。
  275          * @参数 DevAddress      I2C从器件地址
  276          * @参数 addr     I2C从器件内部地址
  277          * @参数 bitStart 第一位的写入位置（0-7）
  278          * @参数 length   写的比特数(不超过8)
  279          * @参数 Data     写入数据
  280          * @返回值 返回状态 (0=成功)
  281          */
  282          uint8 i2c_write_bits(uint8 DevAddress, uint8 addr, uint8 bitStart, uint8 length, uint8 Data)
  283          {
  284   1              //      010 要写入的值
  285   1              // 76543210 比特位
  286   1              //    xxx   args: bitStart=4, length=3
  287   1              // 00011100 掩码字节
  288   1              // 10101111 原始值（样本）
  289   1              // 10100011 原始值 & ~掩码
  290   1              // 10101011 掩码 | 原始值
  291   1              static uint8 b, mask = 0;
  292   1              if (!i2c_mem_read(DevAddress, addr, &b, 1))
  293   1              {
  294   2                      mask = (((1 << length) - 1) << (bitStart - length + 1));        //掩码
  295   2                      Data <<= (bitStart - length + 1);       //把写入的数据移动到位
  296   2                      Data &= mask;
  297   2                      b &= ~(mask);
  298   2                      b |= Data;
  299   2      
  300   2                      return i2c_mem_write(DevAddress, addr, &b, 1);  //写入数据
  301   2              }
  302   1              else
  303   1                      return 1;
  304   1      }
  305          /**读取一个位从8位器件的寄存器。
  306          * @参数 DevAddress      I2C从器件地址
  307          * @参数 addr    I2C从器件内部地址
  308          * @参数 bitNum  位的位置来读取（0-7）
  309          * @参数 *data   数据存储地址
  310          * @返回值（0=成功）
  311          */
  312          uint8 i2c_read_bit(uint8 DevAddress, uint8 addr, uint8 bitNum, uint8 *Data)
  313          {
  314   1              uint8 b;
  315   1              if (!i2c_mem_read(DevAddress, addr, &b, 1))
  316   1              {
  317   2                      *Data = b & (1 << bitNum);
  318   2                      return 0;
  319   2              }
  320   1              else
  321   1              {
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 6   

  322   2                      return 1;
  323   2              }
  324   1      }
  325          /**读取8位寄存器的多个位。
  326          * @参数 DevAddress      I2C从器件地址
  327          * @参数 addr    I2C从器件内部地址
  328          * @参数 bitStart第一位的位置读取（0-7）
  329          * @参数 length  位读取@参数长度数（不超过8）
  330          * @参数 *data   数据存储地址（即'101'任何bitStart位置读取将等于0X05）
  331          * @返回值（0=成功）
  332          */
  333          uint8 i2c_read_bits(uint8 DevAddress, uint8 addr, uint8 bitStart, uint8 length, uint8 *Data)
  334          {
  335   1              // 01101001 读取字节
  336   1              // 76543210 比特位
  337   1              //    xxx   args: bitStart=4, length=3
  338   1              //    010   masked
  339   1              //   -> 010 shifted
  340   1              static uint8 b, mask = 0;
  341   1              if (!i2c_mem_read(DevAddress, addr, &b, 1))
  342   1              {
  343   2      
  344   2                      mask = ((1 << length) - 1) << (bitStart - length + 1);
  345   2                      b &= mask;
  346   2                      b >>= (bitStart - length + 1);
  347   2                      *Data = b;
  348   2                      return 0;
  349   2              }
  350   1              else
  351   1                      return 1;
  352   1      }
  353          
  354          
  355          /////////////////////////////////////////////////////////////////////
  356          void Delay1ms()
  357          {
  358   1              unsigned long i;
  359   1              _nop_();
  360   1              i = 8393UL;
  361   1              while (i) i--;
  362   1      }
  363          
  364          
  365          void MPU_Delay_Ms(uint16 Milliseconds)  //移植时需修改
  366          {
  367   1              while(Milliseconds--)
  368   1                      Delay1ms();
  369   1      }
  370          
  371          //IIC连续写
  372          //reg:要写入的寄存器地址
  373          //len:要写入的长度
  374          //buf:要写入的数据的首地址
  375          //返回值:0,正常
  376          //    其他,错误代码
  377          uint8 MPU_Write_Len(uint8 reg, uint8 len, uint8 *buf)
  378          {
  379   1              return i2c_mem_write(MPU_ADDR, reg, buf, len);
  380   1      }
  381          
  382          //IIC连续读
  383          //reg:要读取的寄存器地址
  384          //len:要读取的长度
  385          //buf:读取到的数据存储区
  386          //返回值:0,正常
  387          //    其他,错误代码
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 7   

  388          uint8 MPU_Read_Len(uint8 reg, uint8 len, uint8 *buf)
  389          {
  390   1              return i2c_mem_read(MPU_ADDR, reg, buf, len);
  391   1      }
  392          
  393          //IIC写一个字节 
  394          //reg:寄存器地址
  395          //Data:数据
  396          //返回值:0,正常
  397          //    其他,错误代码
  398          uint8 MPU_Write_Byte(uint8 reg, uint8 Data)
  399          {
  400   1              return i2c_mem_write(MPU_ADDR, reg, &Data, 1);
  401   1      }
  402          
  403          //IIC读一个字节 
  404          //reg:寄存器地址 
  405          //返回值:读到的数据
  406          uint8 MPU_Read_Byte(uint8 reg)
  407          {
  408   1              uint8 res;
  409   1              i2c_mem_read(MPU_ADDR, reg, &res, 1);
  410   1              return res;
  411   1      }
  412          
  413          //写入8位寄存器的一个位
  414          uint8 MPU_Write_Bit(uint8 addr, uint8 bitNum, uint8 Data)
  415          {
  416   1              return i2c_write_bit(MPU_ADDR, addr, bitNum, Data);
  417   1      }
  418          
  419          //写入8位寄存器的多个位
  420          uint8 MPU_Write_Bits(uint8 addr, uint8 bitStart, uint8 length, uint8 Data)
  421          {
  422   1              return i2c_write_bits(MPU_ADDR, addr, bitStart, length, Data);
  423   1      }
  424          
  425          //读取一个位从8位器件的寄存器
  426          uint8 MPU_Read_Bit(uint8 addr, uint8 bitNum, uint8 *Data)
  427          {
  428   1              return i2c_read_bit(MPU_ADDR, addr, bitNum, Data);
  429   1      }
  430          
  431          //读取8位寄存器的多个位
  432          uint8 MPU_Read_Bits(uint8 addr, uint8 bitStart, uint8 length, uint8 *Data)
  433          {
  434   1              return i2c_read_bits(MPU_ADDR, addr, bitStart, length, Data);
  435   1      }
  436          
  437          //       
  438          //本程序只供学习使用，未经作者许可，不得用于其它任何用途
  439          //ALIENTEK NANO STM32F103开发板 
  440          //MPU6050 驱动代码         
  441          //正点原子@ALIENTEK
  442          //技术论坛:www.openedv.com
  443          //创建日期:2018/7/28
  444          //版本：V1.0
  445          //版权所有，盗版必究。
  446          //Copyright(C) 广州市星翼电子科技有限公司 208-2028
  447          //All rights reserved                                                                     
  448          // 
  449          
  450          //初始化MPU6050
  451          //返回值:0,成功
  452          //    其他,错误代码
  453          uint8 MPU_Init(void)
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 8   

  454          {
  455   1              uint8 res;
  456   1              MPU_Write_Byte(MPU_PWR_MGMT1_REG, 0X80);        //复位MPU6050
  457   1              MPU_Delay_Ms(100);
  458   1              MPU_Write_Byte(MPU_PWR_MGMT1_REG, 0X00);        //唤醒MPU6050 
  459   1              MPU_Set_Gyro_Fsr(3);                                            //陀螺仪传感器,±2000dps
  460   1              MPU_Set_Accel_Fsr(0);                                           //加速度传感器,±2g
  461   1              MPU_Set_Rate(50);                                                       //设置采样率50Hz
  462   1              MPU_Write_Byte(MPU_INT_EN_REG, 0X01);           //使能数据就绪中断
  463   1              MPU_Write_Byte(MPU_USER_CTRL_REG, 0X00);        //I2C主模式关闭
  464   1              MPU_Write_Byte(MPU_FIFO_EN_REG, 0X00);          //关闭FIFO
  465   1              MPU_Write_Byte(MPU_INTBP_CFG_REG, 0X80);        //INT引脚低电平有效
  466   1              res = MPU_Read_Byte(MPU_DEVICE_ID_REG);
  467   1              if (res == MPU_ADDR)//器件ID正确
  468   1              {
  469   2                      MPU_Write_Byte(MPU_PWR_MGMT1_REG, 0X01);        //设置CLKSEL,PLL X轴为参考
  470   2                      MPU_Write_Byte(MPU_PWR_MGMT2_REG, 0X00);        //加速度与陀螺仪都工作
  471   2                      MPU_Set_Rate(200);                                                      //设置采样率为200Hz
  472   2              }
  473   1              else
  474   1                      return 1;
  475   1              return 0;
  476   1      }
  477          
  478          //设置MPU6050陀螺仪传感器满量程范围
  479          //fsr:0,±250dps;1,±500dps;2,±1000dps;3,±2000dps
  480          //返回值:0,设置成功
  481          //    其他,设置失败 
  482          uint8 MPU_Set_Gyro_Fsr(uint8 fsr)
  483          {
  484   1              return MPU_Write_Byte(MPU_GYRO_CFG_REG, fsr << 3);//设置陀螺仪满量程范围  
  485   1      }
  486          
  487          //设置MPU6050加速度传感器满量程范围
  488          //fsr:0,±2g;1,±4g;2,±8g;3,±16g
  489          //返回值:0,设置成功
  490          //    其他,设置失败 
  491          uint8 MPU_Set_Accel_Fsr(uint8 fsr)
  492          {
  493   1              return MPU_Write_Byte(MPU_ACCEL_CFG_REG, fsr << 3);//设置加速度传感器满量程范围  
  494   1      }
  495          
  496          //设置MPU6050的数字低通滤波器
  497          //lpf:数字低通滤波频率(Hz)
  498          //返回值:0,设置成功
  499          //    其他,设置失败 
  500          uint8 MPU_Set_LPF(uint16 lpf)
  501          {
  502   1              uint8 Data = 0;
  503   1              if (lpf >= 188)Data = 1;
  504   1              else if (lpf >= 98)Data = 2;
  505   1              else if (lpf >= 42)Data = 3;
  506   1              else if (lpf >= 20)Data = 4;
  507   1              else if (lpf >= 10)Data = 5;
  508   1              else Data = 6;
  509   1              return MPU_Write_Byte(MPU_CFG_REG, Data);//设置数字低通滤波器  
  510   1      }
  511          
  512          //设置MPU6050的采样率(假定Fs=1KHz)
  513          //rate:4~1000(Hz)
  514          //返回值:0,设置成功
  515          //    其他,设置失败 
  516          uint8 MPU_Set_Rate(uint16 rate)
  517          {
  518   1              static uint8 Data;
  519   1              if (rate>1000)rate = 1000;
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 9   

  520   1              if (rate<4)rate = 4;
  521   1              Data = 1000 / rate - 1;
  522   1              Data = MPU_Write_Byte(MPU_SAMPLE_RATE_REG, Data);       //设置数字低通滤波器
  523   1              return MPU_Set_LPF(rate / 2);   //自动设置LPF为采样率的一半
  524   1      }
  525          
  526          //得到温度值
  527          //返回值:温度值(扩大了100倍)
  528          short MPU_Get_Temperature(void)
  529          {
  530   1              uint8 buf[2];
  531   1              short raw;
  532   1              float temp;
  533   1              MPU_Read_Len(MPU_TEMP_OUTH_REG, 2, buf);
  534   1              raw = ((uint16)buf[0] << 8) | buf[1];
  535   1              temp = 36.53 + ((double)raw) / 340;
  536   1              return temp * 100;;
  537   1      }
  538          
  539          //得到陀螺仪值(原始值)
  540          //gx,gy,gz:陀螺仪x,y,z轴的原始读数(带符号)
  541          //返回值:0,成功
  542          //    其他,错误代码
  543          uint8 MPU_Get_Gyroscope(short *gx, short *gy, short *gz)
  544          {
  545   1              uint8 buf[6], res;
  546   1              res = MPU_Read_Len(MPU_GYRO_XOUTH_REG, 6, buf);
  547   1              if (res == 0)
  548   1              {
  549   2                      *gx = ((uint16)buf[0] << 8) | buf[1];
  550   2                      *gy = ((uint16)buf[2] << 8) | buf[3];
  551   2                      *gz = ((uint16)buf[4] << 8) | buf[5];
  552   2              }
  553   1              return res;;
  554   1      }
  555          
  556          //得到加速度值(原始值)
  557          //gx,gy,gz:陀螺仪x,y,z轴的原始读数(带符号)
  558          //返回值:0,成功
  559          //    其他,错误代码
  560          uint8 MPU_Get_Accelerometer(short *ax, short *ay, short *az)
  561          {
  562   1              uint8 buf[6], res;
  563   1              res = MPU_Read_Len(MPU_ACCEL_XOUTH_REG, 6, buf);
  564   1              if (res == 0)
  565   1              {
  566   2                      *ax = ((uint16)buf[0] << 8) | buf[1];
  567   2                      *ay = ((uint16)buf[2] << 8) | buf[3];
  568   2                      *az = ((uint16)buf[4] << 8) | buf[5];
  569   2              }
  570   1              return res;;
  571   1      }
  572          
  573          
  574          /****************************************************
  575          功能:   采集MPU6050 DMP 数据
  576          */
  577          
  578          
  579          float Q[4];     //四元数
  580          
  581          uint8 dmpdatas[42];     //DMP数据
  582          
  583          //以下的 firmware 及 config update 数据来自于 Jeff Jrowberg 公开的程序
  584          /* ================================================================================================ *
  585          | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 10  

  586          |                                                                                                  |
  587          | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
  588          |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
  589          |                                                                                                  |
  590          | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
  591          |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
  592          * ================================================================================================ */
  593           uint8 code dmpmemorydata[1929] = 
  594          {
  595                  // bank 0, 256 bytes
  596                  0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
  597                  0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
  598                  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  599                  0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
  600                  0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
  601                  0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  602                  0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
  603                  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
  604                  0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
  605                  0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
  606                  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  607                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
  608                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  609                  0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
  610                  0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
  611                  0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
  612                  // bank 1, 256 bytes
  613                  0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  614                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
  615                  0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
  616                  0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
  617                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
  618                  0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
  619                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
  620                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  621                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  622                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  623                  0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
  624                  0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
  625                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
  626                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  627                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  628                  0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
  629                  // bank 2, 256 bytes
  630                  0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  631                  0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
  632                  0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
  633                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  634                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  635                  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  636                  0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  637                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  638                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  639                  0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  640                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  641                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  642                  0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  643                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  644                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  645                  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  646                  // bank 3, 256 bytes
  647                  0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
  648                  0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
  649                  0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
  650                  0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
  651                  0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 11  

  652                  0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
  653                  0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
  654                  0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
  655                  0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
  656                  0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
  657                  0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
  658                  0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
  659                  0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
  660                  0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
  661                  0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
  662                  0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
  663                  // bank 4, 256 bytes
  664                  0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
  665                  0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
  666                  0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
  667                  0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
  668                  0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
  669                  0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
  670                  0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
  671                  0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
  672                  0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
  673                  0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
  674                  0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
  675                  0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
  676                  0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
  677                  0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
  678                  0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
  679                  0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
  680                  // bank 5, 256 bytes
  681                  0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
  682                  0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
  683                  0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
  684                  0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
  685                  0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
  686                  0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
  687                  0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
  688                  0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
  689                  0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
  690                  0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
  691                  0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
  692                  0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
  693                  0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
  694                  0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
  695                  0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
  696                  0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
  697                  // bank 6, 256 bytes
  698                  0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
  699                  0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
  700                  0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
  701                  0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
  702                  0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
  703                  0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
  704                  0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
  705                  0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
  706                  0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
  707                  0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
  708                  0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
  709                  0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
  710                  0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
  711                  0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
  712                  0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
  713                  0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
  714                  // bank 7, 138 bytes (remainder)
  715                  0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
  716                  0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
  717                  0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 12  

  718                  0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
  719                  0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
  720                  0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
  721                  0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
  722                  0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
  723                  0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
  724          };
  725          
  726           uint8 code dmpcfgupddata[192] = 
  727          {
  728          //  dmp config 
  729          //  BANK    OFFSET  LENGTH  [DATA]
  730                  0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,
  731                  0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,
  732                  0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,
  733                  0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,
  734                  0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,
  735                  0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
  736                  0x03,   0x89,   0x03,   0x26, 0x46, 0x66,
  737                  0x00,   0x6C,   0x02,   0x20, 0x00,
  738                  0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,
  739                  0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,
  740                  0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,
  741                  0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,
  742                  0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,
  743                  0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,
  744                  0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,
  745                  0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,
  746                  0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,
  747                  0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,
  748                  0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
  749                  0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,
  750                  0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,
  751                  0x00,   0xA3,   0x01,   0x00,
  752                  0x00,   0x00,   0x00,   0x01,   //这里是开启DMP的特殊中断的
  753                  //原程序中此行代码为(这里不一定错)
  754                  //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错
  755                  0x07,   0x86,   0x01,   0xFE,
  756                  0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,
  757                  0x07,   0x7E,   0x01,   0x30,
  758                  0x07,   0x46,   0x01,   0x9A,
  759                  0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,
  760                  0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,
  761                  0x02,   0x16,   0x02,   0x00, 0x01,
  762                  /* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,
  763                  // 可从 datasheet 公式推算
  764                  //dmp updates
  765                  0x01,   0xB2,   0x02,   0xFF, 0xFF,
  766                  0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
  767                  0x01,   0x6A,   0x02,   0x06, 0x00,
  768                  0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  769                  0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
  770                  0x01,   0x62,   0x02,   0x00, 0x00,
  771                  0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/
  772          };
  773          
  774           uint8 code dmpUpdates[47] = 
  775          {
  776                  0x01,   0xB2,   0x02,   0xFF, 0xFF,
  777                  0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
  778                  0x01,   0x6A,   0x02,   0x06, 0x00,
  779                  0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  780                  0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
  781                  0x01,   0x62,   0x02,   0x00, 0x00,
  782                  0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
  783          
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 13  

  784          };
  785          
  786          /*
  787          加载 DMP代码到
  788          返回值  (1=成功,0=失败)
  789          */
  790          uint8 loadfirmware(void)
  791          {
  792   1              uint16 datanum = 0;     //DMP固件写入标志位
  793   1              uint8 ye, i/*, j*/;
  794   1              uint8 bank = 0; //段（256个数据一段）
  795   1              uint8 addr = 0;
  796   1      
  797   1              for (; bank<8; bank++)
  798   1              {
  799   2                      if (bank == 7)  //这里的作用就是区分最后一段数据
  800   2                              i = 8;
  801   2                      else
  802   2                              i = 16;
  803   2                      for (ye = 0; ye<i; ye++)
  804   2                      {
  805   3                              MPU_Write_Byte(0x6d, bank);
  806   3                              MPU_Write_Byte(0x6e, addr);
  807   3                              MPU_Write_Len(0x6f, 16, dmpmemorydata + datanum);
  808   3                              datanum += 16;
  809   3                              addr += 16;
  810   3                      }
  811   2              }
  812   1              MPU_Write_Byte(0x6d, 7);
  813   1              MPU_Write_Byte(0x6e, addr);
  814   1              MPU_Write_Len(0x6f, 9, dmpmemorydata + datanum);
  815   1              datanum += 9;
  816   1              return 1;
  817   1      }
  818          
  819          uint8 loadcfgupd(void)  //DMP设置
  820          {
  821   1              uint8 line;     //一共需要写入30条设置数据
  822   1              uint8 bank;     //页
  823   1              uint8 datacounts = 0;   //DMP设置数据标志位
  824   1              uint8 bytes2write;      //数据长度。
  825   1              uint8 offset;   //偏移地址
  826   1              static uint8 writingcounts;     //数据写入标志与bytes2write一同使用
  827   1              uint8 special;
  828   1      
  829   1              for (line = 0; line<30; line++)
  830   1              {
  831   2                      bank = dmpcfgupddata[datacounts++];
  832   2                      offset = dmpcfgupddata[datacounts++];
  833   2                      bytes2write = dmpcfgupddata[datacounts++];
  834   2                      MPU_Write_Byte(0x6d, bank);
  835   2                      MPU_Write_Byte(0x6e, offset);
  836   2                      MPU_Write_Len(0x6f, bytes2write, dmpcfgupddata + datacounts);
  837   2                      writingcounts = bytes2write;
  838   2                      datacounts += bytes2write;
  839   2                      if (0 == bytes2write)
  840   2                      {
  841   3                              special = dmpcfgupddata[datacounts++];
  842   3                              if (0x01 == special)
  843   3                              {
  844   4                                      //设置零运动中断启用（真）;
  845   4                                      //设置FIFO缓冲区溢出启用（真）;
  846   4                                      //设置DMP启用（真）;
  847   4                                      MPU_Write_Byte(MPU_INT_EN_REG, 0x32);
  848   4                              }
  849   3                              else
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 14  

  850   3                                      return 0;
  851   3                      }
  852   2              }
  853   1              return 1;
  854   1      }
  855          
  856          /*最后更新DMP*/
  857          uint8 xdmpUpdates(uint8 volatile datacounts)
  858          {
  859   1          static uint8 writingcounts; // 删除未使用的静态变量声明
  860   1          uint8 bank, offset;
  861   1          uint8 bytes2write;
  862   1          bank = dmpUpdates[datacounts++];
  863   1          offset = dmpUpdates[datacounts++];
  864   1          bytes2write = dmpUpdates[datacounts++];
  865   1          MPU_Write_Byte(0x6d, bank);
  866   1          MPU_Write_Byte(0x6e, offset);
  867   1          MPU_Write_Len(0x6f, bytes2write, dmpUpdates + datacounts);
  868   1          writingcounts = bytes2write; // 删除未使用的赋值语句
  869   1          datacounts += bytes2write;
  870   1          return 1;
  871   1      }
  872          
  873          
  874          /*读取 FIFO 计数*/
  875          uint16 getFIFOCount()
  876          {
  877   1              uint8 i[2];
  878   1              MPU_Read_Len(MPU_FIFO_CNTH_REG, 2, i);
  879   1              return ((i[0] << 8) + i[1]);
  880   1      }
  881          
  882          /*FIFO数据读取
  883          参数 *Data      存储数据的地址
  884          返回值 (1=读取成功,0读取失败)
  885          */
  886          uint8 readdmp(uint8 *Data)
  887          {
  888   1              return !MPU_Read_Len(MPU_FIFO_RW_REG, 42, Data);
  889   1      }
  890          
  891          //加载并配置 DMP 数字运动处理引擎
  892          uint8 dmpInitialize(void)
  893          {
  894   1              uint8 hwRevision, otpValid, mpuIntStatus/*fifoBuffer[128]*/;
  895   1              uint8 xgOffsetTC, ygOffsetTC, zgOffsetTC;
  896   1              static uint16 fifoCount;
  897   1              MPU_Write_Bit(MPU_PWR_MGMT1_REG, 7, 1); //复位 MPU6050
  898   1              MPU_Delay_Ms(30);
  899   1              MPU_Write_Bit(MPU_PWR_MGMT1_REG, 6, 0); //禁止睡眠模式
  900   1              MPU_Write_Byte(0x6D, 0x70);     //写入一个字节数据到0x6d寄存器(选择用户 bank)
  901   1              MPU_Write_Byte(0x6E, 0x06);     //写入一个字节数据到0x6e寄存器(选择存储字节)
  902   1              MPU_Read_Len(0x6F, 1, &hwRevision);     //读取 
  903   1              MPU_Write_Byte(0x6D, 0);        //重置内存 bank 选择
  904   1              MPU_Read_Bit(0x00, 0, &otpValid);       //读取 OTP bank 有效标志
  905   1              MPU_Read_Bits(0x00, 6, 6, &xgOffsetTC); //读陀螺偏置TC值 X
  906   1              MPU_Read_Bits(0x01, 6, 6, &ygOffsetTC); //读陀螺偏置TC值 Y)
  907   1              MPU_Read_Bits(0x02, 6, 6, &zgOffsetTC); //读陀螺偏置TC值 Z
  908   1              //MPU_Write_Byte(MPU_I2CSLV0_ADDR_REG,0x7f);    //设置从0地址 0x7
  909   1              //MPU_Write_Bit(MPU_USER_CTRL_REG,5,0); //禁用I2C主模式
  910   1              //MPU_Write_Byte(MPU_I2CSLV0_ADDR_REG,0x68);    //这里可能要改。还没有弄明白这里
  911   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 1, 1); //I2C总线主控复位
  912   1              MPU_Delay_Ms(20);
  913   1              if ((loadfirmware()) == 0) 
  914   1                      return 0;       //加载 
  915   1              if ((loadcfgupd()) == 0) 
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 15  

  916   1                      return 0;       //配置DMP
  917   1              MPU_Write_Bits(MPU_PWR_MGMT1_REG, 2, 3, 0x03);  //设置时钟脉冲源Z陀螺
  918   1              MPU_Write_Byte(MPU_INT_EN_REG, 0x12);   //设置DMP和FIFO_OFLOW启用中断
  919   1              MPU_Write_Byte(MPU_SAMPLE_RATE_REG, 4); //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)
  920   1              MPU_Write_Bits(MPU_CFG_REG, 5, 3, 0x1); //设置外部帧同步TEMP_OUT_L[0]
  921   1              MPU_Write_Bits(MPU_CFG_REG, 2, 3, 0x03);        //设置DLPF带宽42赫兹
  922   1              MPU_Write_Bits(MPU_GYRO_CFG_REG, 4, 2, 0x03);   //陀螺灵敏度设置为+ / - 2000 deg/sec
  923   1              MPU_Write_Byte(0x70, 0x03);     //设置DMP配置字节（功能未知）
  924   1              MPU_Write_Byte(0x71, 0x00);     //设置DMP配置字节（功能未知）
  925   1              MPU_Write_Bit(0x00, 0, 0);      //清除OTP Bank 标志
  926   1              MPU_Write_Bits(0x00, 6, 6, 0);  //设置X 陀螺抵消TCs之前的值
  927   1              MPU_Write_Bits(0x01, 6, 6, 0);  //设置Y 陀螺抵消TCs之前的值
  928   1              MPU_Write_Bits(0x02, 6, 6, 0);  //设置Z 陀螺抵消TCs之前的值
  929   1              if (xdmpUpdates(0) == 0) 
  930   1                      return 0;       //最后更新1/7(函数未知)dmpUpdates数组第一行
  931   1              if (xdmpUpdates(5) == 0) 
  932   1                      return 0;       //最后更新2/7(函数未知)dmpUpdates数组第二行
  933   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  934   1              fifoCount = getFIFOCount();     //读取 FIFO 计数
  935   1                                                                      //readdmp(fifoCount,fifoBuffer);        //读取FIFO里的数据
  936   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  937   1      
  938   1              MPU_Write_Byte(MPU_MOTION_DET_REG, 2);  //运动检测阈值设置为2
  939   1              MPU_Write_Byte(0x21, 156);      //零运动检测阈值为156
  940   1              MPU_Write_Byte(0x20, 80);       //设置运动检测持续时间至80
  941   1              MPU_Write_Byte(0x22, 0);        //设置零运动检测时间0
  942   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复 位 FIFO
  943   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 6, 1); //使能 FIFO
  944   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 1); //使能 DMP
  945   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 3, 1); //复位 DMP
  946   1              if (xdmpUpdates(12) == 0) 
  947   1                      return 0;       //最后更新3/7(函数未知)dmpUpdates数组第三行
  948   1              if (xdmpUpdates(17) == 0) 
  949   1                      return 0;       //最后更新4/7(函数未知)dmpUpdates数组第四行
  950   1              if (xdmpUpdates(28) == 0) 
  951   1                      return 0;       //最后更新5/7(函数未知)dmpUpdates数组第五行
  952   1              while ((fifoCount = getFIFOCount()) < 3);       //等待 FIFO 计数 > 2
  953   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);                 //复位 FIFO
  954   1              //readdmp(fifoCount,fifoBuffer);        //读取FIFO里的数据
  955   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);                //读取中断状态
  956   1              if (xdmpUpdates(35) == 0) 
  957   1                      return 0;       //最后更新6/7(函数未知)dmpUpdates数组第六行
  958   1              while ((fifoCount = getFIFOCount()) < 3);       //等待 FIFO 计数 > 2
  959   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  960   1              //readdmp(fifoCount,fifoBuffer);        //读取FIFO里的数据
  961   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);        //读取中断状态
  962   1              if (xdmpUpdates(40) == 0) 
  963   1                      return 0;       //最后更新7/7(函数未知)dmpUpdates数组第七行
  964   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 0); //禁用DMP(稍后您打开它)
  965   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  966   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);
  967   1              //星期六 (2014/06/28)
  968   1              return 1;
  969   1      }
  970          
  971          /*初始化MPU6050*/
  972          void initMPU6050(void)
  973          {
  974   1              MPU_Write_Bits(MPU_PWR_MGMT1_REG, 2, 3, 0x01);  //电源管理
  975   1              MPU_Write_Bits(MPU_GYRO_CFG_REG, 4, 2, 0x00);   //设置陀螺仪量程 2000/s
  976   1              MPU_Write_Bits(MPU_ACCEL_CFG_REG, 4, 2, 0x00);  //设置加速度量程 16G
  977   1              MPU_Write_Bit(MPU_PWR_MGMT1_REG, 6, 1); //电源管理MUP进入睡眠模式
  978   1      }
  979          
  980          /*验证MPU6050连接*/
  981          uint8 getDeviceID(void)
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 16  

  982          {
  983   1              uint8 b = 0;    //临时变量
  984   1              MPU_Read_Bits(MPU_DEVICE_ID_REG, 6, 6, &b);     //读取i2c固定地址，去掉最高位和最低位这两位数据
  985   1              return b == 0x34;       //判断B是否等于0x34，如果等于返回1，不等于返回0(库的是0x38)
  986   1      
  987   1      }
  988          
  989          void MPU6050_DMP_Init(void)
  990          {
  991   1              initMPU6050();  //初始化
  992   1              if (getDeviceID())      //验证连接是否正常(读取MPU6050的I2C地址)
  993   1              while(!(dmpInitialize()));      //加载并配置运动库
  994   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
  995   1              MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 1); //使能DMP
  996   1      }
  997          
  998          float z_add=0,z_last=0,z_now=0;char mpu_state=0;
  999          void MPU6050_Refresh_DMP(void)
 1000          {
 1001   1              static uint8 zd;
 1002   1              static uint16 i;
 1003   1        
 1004   1              i = getFIFOCount();//读取FIFO计数
 1005   1              MPU_Read_Len(MPU_INT_STA_REG, 1, &zd);  //读取中断状态
 1006   1              if ((zd & 0x10) || i >= 840)    //判断FIFO是否溢出
 1007   1              {
 1008   2                      MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
 1009   2              }
 1010   1              else if (zd & 0x02)
 1011   1              {
 1012   2                      while (i<42) 
 1013   2                              i = getFIFOCount();
 1014   2                      if (readdmp(dmpdatas))  //读取FIFO数据
 1015   2                      {
 1016   3                              Q[0] = ((int16)dmpdatas[0] << 8 | dmpdatas[1])/16384.;
 1017   3                              Q[1] = ((int16)dmpdatas[4] << 8 | dmpdatas[5])/16384.;
 1018   3                              Q[2] = ((int16)dmpdatas[8] << 8 | dmpdatas[9])/16384.;
 1019   3                              Q[3] = ((int16)dmpdatas[12] << 8 | dmpdatas[13])/16384.;
 1020   3                      }
 1021   2              }
 1022   1      
 1023   1              
 1024   1      
 1025   1                      Pitch = asin(-2 * Q[1] * Q[3] + 2 * Q[0]* Q[2])* 57.3 - x1;     // pitch
 1026   1                      Roll  = atan2(2 * Q[2] * Q[3] + 2 * Q[0] * Q[1], -2 * Q[1] * Q[1] - 2 * Q[2]* Q[2] + 1)* 57.3 - y1;     // 
             -roll
 1027   1                      z_now =atan2(2 * (Q[1] * Q[2] + Q[0] * Q[3]), Q[0] * Q[0] + Q[1] * Q[1] - Q[2] * Q[2] - Q[3] * Q[3]) * 
             -57.3 - z1;        //yaw
 1028   1              
 1029   1              if(z_last-z_now>300){mpu_state+=1;}         //180到-180
 1030   1              else if(z_last-z_now<-300){mpu_state-=1;}   //-180到180
 1031   1              
 1032   1              if(mpu_state==0)Yaw=z_now;
 1033   1              if(mpu_state>0)Yaw=360*mpu_state+z_now;
 1034   1              if(mpu_state<0)Yaw=z_now+360*mpu_state;
 1035   1              
 1036   1                z_last=z_now;
 1037   1              
 1038   1                Yaw=Yaw-z1;
 1039   1      
 1040   1      }
 1041          
 1042          
 1043          
 1044          void zero_all()
 1045          {
C251 COMPILER V5.60.0,  MPU6050                                                            20/07/24  20:01:28  PAGE 17  

 1046   1              x1=0,y1=0,z1=0;mpu_state=0;
 1047   1              MPU6050_Refresh_DMP();
 1048   1              x1=Pitch,y1=Roll,z1=z_now;
 1049   1              MPU6050_Refresh_DMP();
 1050   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5527     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       107         62
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        87     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
