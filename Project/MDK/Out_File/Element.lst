C251 COMPILER V5.60.0,  Element                                                            26/04/24  10:40:39  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Element
OBJECT MODULE PLACED IN .\Out_File\Element.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\CODE\Element.c XSMALL INTR2 WARNINGLEVEL(3) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\Element.lst) OBJECT(.\Out_File\Element.obj) 

stmt  level    source

    1          #include "isr.h"
    2          #include <string.h>
    3          #include <stdio.h>
    4          #include "common.h"
    5          #include "Element.h"
    6          #include "Motor.h"
    7          #include "PID.h"
    8          #include "Buzzer.h"
    9          #include "MPU6050.h"
   10          
   11          extern float Exp_Speed;
   12          extern float Ratio;
   13          extern float ADC_proc[5];
   14          
   15          //上下坡标志位
   16          char Up_Down_Flag = 0;
   17          char Down_Flag = 0;
   18          float Circle_Delay1 = 0;        
   19          float Circle_Delay2 = 0;
   20          
   21          //环岛标志位
   22          float Circle_Flag1 = 0;  // 左右环岛标志位
   23          float Circle_Flag4 = 0;
   24          float Circle_Flag2 = 0;
   25          char Circle_Flag3 = 0; 
   26          
   27          char Special_Elem = 0;
   28          
   29          
   30          void Elem_Up_Down(float Angle)  
   31          {
   32   1          static char Elem_Over;
   33   1              if(Angle > -2)          //上坡
   34   1                      Exp_Speed = 320;
   35   1              else if(Angle < -16)  //下坡
   36   1          {
   37   2              Down_Flag = 5;
   38   2              if(Elem_Over == 0)
   39   2              {
   40   3                  Elem_Over=1;
   41   3                  Special_Elem++;
   42   3              }
   43   2          }
   44   1          
   45   1      }
   46          
   47          
   48          //障碍物识别   
   49          char Barrier_Executed = 0;
   50          char Barrier_Flag1 = 0;
   51          void Elem_Barrier_Timer(void)  
   52          {
   53   1              static float Barrier_Timer;     
   54   1              #if BARRIER_DIR == 0                                            //向右避障
                               if(Barrier_Flag1 == 1)                                  //识别到障碍物
                               {
                                       Barrier_Timer--;
C251 COMPILER V5.60.0,  Element                                                            26/04/24  10:40:39  PAGE 2   

                                       if(Barrier_Timer > 90)
                                               Ratio = -0.235;
                                       else if(Barrier_Timer > 30 && Barrier_Timer <= 90)
                                               Ratio = 0.5;
                                       else 
                                               Ratio -= 0.06;
                                       if(Barrier_Timer == 0)
                                       {
                                               Barrier_Flag1 = 0;
                                               Barrier_Executed = 1;
                               Special_Elem = 0;
                                       }
                               }
                               else
                                       Barrier_Timer = 100;
                       #elif BARRIER_DIR == 1  
   74   1                      //向左避障
   75   1                      if(Barrier_Flag1 == 1)                                  //识别到障碍物
   76   1                      {
   77   2                              Barrier_Timer--;
   78   2                              if(Barrier_Timer > 64)
   79   2                                      Ratio = 0.49;
   80   2                              else if(Barrier_Timer > 18 && Barrier_Timer <= 64)
   81   2                                      Ratio = -0.43;
   82   2                              else 
   83   2                                      Ratio += 0.04;
   84   2                              if(Barrier_Timer == 0)
   85   2                              {
   86   3                                      Barrier_Flag1 = 0;
   87   3                                      Barrier_Executed = 1;
   88   3                      Special_Elem = 0;
   89   3                              }
   90   2                      }
   91   1                      else
   92   1                              Barrier_Timer = 100;
   93   1                      
   94   1              #endif
   95   1      }
   96          
   97          
   98          
   99          void Elem_Circle(float Speed,float Gyro_Z)
  100          {
  101   1          static char Elem_Over;
  102   1              static float Sum_Dis1 = 0;
  103   1              static float Sum_Angle_C1 = 0;
  104   1          
  105   1              Gyro_Z = (Gyro_Z*2000)/32768;
  106   1              if(Circle_Delay2 > 0)                                   //出环，清除标志位
  107   1              {
  108   2                      Circle_Flag1 = 0;
  109   2                      Circle_Flag2 = 0;
  110   2                      if(Circle_Flag3 == LEFT_CIRCLE)         //用来记录出环时的方向
  111   2                              Ratio -=0.05;
  112   2                      else if(Circle_Flag3 == RIGHT_CIRCLE)
  113   2                              Ratio +=0.05;
  114   2                      Circle_Delay2--;
  115   2                      return ;                                                //退出函数
  116   2              }
  117   1      
  118   1              if(Circle_Flag1 == 1)                                           //识别到环岛
  119   1              {
  120   2                      if(Sum_Dis1 > DIS_ROUND_IN)                     //路程积分，积满进环
  121   2                      {
  122   3                              Sum_Angle_C1 += Gyro_Z * 0.005;
  123   3                              if(Circle_Flag2 == 0 && (ADC_proc[1]+ ADC_proc[0] >= ADC_proc[3]+ADC_proc[4]))          //标志位未清零时只置位
C251 COMPILER V5.60.0,  Element                                                            26/04/24  10:40:39  PAGE 3   

             -一次
  124   3                              {
  125   4                                      Circle_Flag2 = LEFT_CIRCLE;
  126   4                                      x10_ms = 13;
  127   4                              }
  128   3                              else if(Circle_Flag2 == 0 && (ADC_proc[1]+ ADC_proc[0] < ADC_proc[3]+ADC_proc[4]))
  129   3                              {
  130   4                                      Circle_Flag2 = RIGHT_CIRCLE;
  131   4                                      x10_ms = 13;
  132   4                              }
  133   3                              
  134   3                              Circle_Flag3 = Circle_Flag2;                                                                                                            //变量记录方向
  135   3                              
  136   3                              if(Sum_Angle_C1 <  24 && Circle_Flag2 == LEFT_CIRCLE )                                                          //角度积满，入环成功，正常循迹
  137   3                              {
  138   4                      Ratio = 0.5;  
  139   4                  }
  140   3                              else if(Sum_Angle_C1 > -24 && Circle_Flag2 == RIGHT_CIRCLE)
  141   3                              {
  142   4                      Ratio = -0.5;
  143   4                  }
  144   3                      }
  145   2                      else
  146   2                              Sum_Dis1+=Speed;
  147   2                      
  148   2                      if(Sum_Angle_C1 > ROUND_L || Sum_Angle_C1 < ROUND_R )                                                                   //出环条件之一，角度积分够大
  149   2                      {
  150   3                              if(ADC_proc[0] > 59 || ADC_proc[4] > 59 || ADC_proc[2] > 62)                                            //预出环 防止误判再次入环
  151   3                              {
  152   4                      Circle_Delay2 = 100;   //延时1000ms
  153   4                                      Sum_Dis1 = 0;
  154   4                                      Sum_Angle_C1 = 0;
  155   4                                      Circle_Flag2 = 0;
  156   4                     // Circle_Flag4 = 0;
  157   4                      //Circle_Flag1 = 0;
  158   4                      if(Elem_Over == 0)
  159   4                      {
  160   5                          Elem_Over = 1;
  161   5                          Special_Elem++;
  162   5                      }
  163   4                              }
  164   3                      }
  165   2              }
  166   1              else
  167   1              {
  168   2                      Sum_Dis1 = 0;
  169   2                      Sum_Angle_C1 = 0;
  170   2                      Circle_Flag2 = 0;
  171   2              //Circle_Flag4 = 0;
  172   2              }
  173   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       715     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        40     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
C251 COMPILER V5.60.0,  Element                                                            26/04/24  10:40:39  PAGE 4   

  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        86     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
