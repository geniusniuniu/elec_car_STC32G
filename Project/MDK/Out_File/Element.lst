C251 COMPILER V5.60.0,  Element                                                            20/07/24  17:24:57  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Element
OBJECT MODULE PLACED IN .\Out_File\Element.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\CODE\Element.c XSMALL INTR2 WARNINGLEVEL(3) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\Element.lst) OBJECT(.\Out_File\Element.obj) 

stmt  level    source

    1          #include "isr.h"
    2          #include <string.h>
    3          #include <stdio.h>
    4          #include "common.h"
    5          #include "Element.h"
    6          #include "Motor.h"
    7          #include "PID.h"
    8          #include "Buzzer.h"
    9          #include "MPU6050.h"
   10          #include "isr.h"
   11          
   12          extern float Ratio;
   13          extern float ADC_proc[5];
   14          
   15          //下坡标志位
   16          char Down_Flag = 0;
   17          
   18          //环岛标志位
   19          float Circle_Flag1 = 0;  // 左右环岛标志位
   20          float Circle_Flag2 = 0;
   21          
   22          
   23          //出环延时
   24          int circle_Delay1 = 0;
   25          int Circle_Delay2 = 0;
   26          
   27          //记录元素个数
   28          char Special_Elem = 0;
   29          
   30          
   31          void Elem_Up_Down(float Angle)  
   32          {
   33   1          static char Elem_Over;
   34   1              if(Angle > 5.5)          //上坡
   35   1                      Exp_Speed = 320;
   36   1              else if(Angle < -10)  //下坡
   37   1          {
   38   2              Down_Flag = 5;
   39   2              if(Elem_Over == 0)
   40   2              {
   41   3                  Elem_Over=1;
   42   3                  Special_Elem++;
   43   3              }
   44   2          }
   45   1          
   46   1      }
   47          
   48          
   49          //障碍物识别   
   50          char Barrier_Executed = 1;
   51          char Barrier_Flag1 = 0;
   52          //void Elem_Barrier_Timer(void)  
   53          //{
   54          //      static float Barrier_Timer;     
   55          //      #if BARRIER_DIR == 0                                            //向右避障
   56          //              if(Barrier_Flag1 == 1)                                  //识别到障碍物
   57          //              {
C251 COMPILER V5.60.0,  Element                                                            20/07/24  17:24:57  PAGE 2   

   58          //            Exp_Speed = 220;
   59          //                      Barrier_Timer--;
   60          //                      if(Barrier_Timer > 90)
   61          //                              Ratio = -0.235;
   62          //                      else if(Barrier_Timer > 30 && Barrier_Timer <= 90)
   63          //                              Ratio = 0.5;
   64          //                      else 
   65          //                              Ratio -= 0.06;
   66          //                      if(Barrier_Timer == 0)
   67          //                      {
   68          //                              Barrier_Flag1 = 0;
   69          //                              Barrier_Executed = 1;
   70          //                Special_Elem = 0;
   71          //                      }
   72          //              }
   73          //              else
   74          //                      Barrier_Timer = 130;
   75          //      #elif BARRIER_DIR == 1  
   76          //              //向左避障
   77          //              if(Barrier_Flag1 == 1)                                  //识别到障碍物
   78          //              {
   79          //            Exp_Speed = 220;
   80          //                      Barrier_Timer--;
   81          //                      if(Barrier_Timer > 70)
   82          //                              Ratio = 0.49;
   83          //                      else if(Barrier_Timer > 18 && Barrier_Timer <= 70)
   84          //                              Ratio = -0.43;
   85          //                      else 
   86          //                              Ratio += 0.04;
   87          //                      if(Barrier_Timer == 0)
   88          //                      {
   89          //                              Barrier_Flag1 = 0;
   90          //                              Barrier_Executed = 1;
   91          //                Special_Elem = 0;
   92          //                      }
   93          //              }
   94          //              else
   95          //                      Barrier_Timer = 120;
   96          //              
   97          //      #endif
   98          //}
   99          
  100          
  101          char Barrier_Flag2 = 0;
  102          char Barrier_Flag3 = 0;
  103          float Dis_Bar = 0;
  104          float Sum_Angle_Bar = 0;
  105          void Elem_Barrier(float Gyro_Z,float Speed)
  106          {
  107   1              Gyro_Z = (Gyro_Z*2000)/32768;   
  108   1          
  109   1              #if BARRIER_DIR == 0                //向右避障
  110   1                      if(Barrier_Flag1==1)        
  111   1                      {
  112   2                  Sum_Angle_Bar += Gyro_Z*0.005;
  113   2                  Dis_Bar += Speed;
  114   2                              Ratio = -0.385;                 
  115   2      
  116   2                      }
  117   1                      if(Sum_Angle_Bar < -23 && Dis_Bar > 4000) 
  118   1                      {
  119   2                              Barrier_Flag1 = 0;   
  120   2                              Barrier_Flag2 = 1;
  121   2                      }
  122   1                      if(Barrier_Flag2 == 1)      //左拐
  123   1                      {   
C251 COMPILER V5.60.0,  Element                                                            20/07/24  17:24:57  PAGE 3   

  124   2                  Sum_Angle_Bar += Gyro_Z*0.005;
  125   2                  Dis_Bar += Speed;
  126   2                              if(Sum_Angle_Bar > 21 && Dis_Bar > 8000)  
  127   2                              {
  128   3                      Barrier_Flag3 = 1;  //回正标志位                   
  129   3                              }
  130   2                              else                //回正
  131   2                                      Ratio = 0.395; 
  132   2                      }
  133   1          #elif BARRIER_DIR == 1               //向左避障
                               if(Barrier_Flag1==1)        
                               {
                           Sum_Angle_Bar += Gyro_Z*0.005;
                           Dis_Bar += Speed;
                                       Ratio = 0.425;                  
               
                               }
                               if(Sum_Angle_Bar > 23 && Dis_Bar > 4000) 
                               {
                                       Barrier_Flag1 = 0;   
                                       Barrier_Flag2 = 1;
                               }
                               if(Barrier_Flag2 == 1)      //右拐
                               {   
                           Sum_Angle_Bar += Gyro_Z*0.005;
                           Dis_Bar += Speed;
                                       if(Sum_Angle_Bar < -22 && Dis_Bar > 8000)  
                                       {
                               Barrier_Flag3 = 1;  //回正标志位                   
                                       }
                                       else                //回正
                                               Ratio = -0.395; 
                               }
                  #endif
  158   1              
  159   1          if(Barrier_Flag3 == 1)              //回正后标志位清零
  160   1          {
  161   2              Sum_Angle_Bar = 0;
  162   2              Dis_Bar = 0;
  163   2              Barrier_Flag1 = 0;            
  164   2              Barrier_Flag2 = 0;
  165   2              Barrier_Executed = 1;
  166   2              
  167   2              Barrier_Flag3 = 0;
  168   2          }        
  169   1      }
  170          
  171          
  172          char Circle_Flag3 = 0;
  173          void Elem_Circle(float Speed,float Gyro_Z)
  174          {
  175   1          static char Elem_Over;
  176   1              static float Sum_Dis1 = 0;
  177   1          static float Sum_Angle_C1 = 0;
  178   1              if(Circle_Delay2 > 0)                                   //出环，清除标志位
  179   1              {
  180   2                      Circle_Flag1 = 0;
  181   2                      Circle_Flag2 = 0;
  182   2              if(Circle_Delay2 < 70)
  183   2                      {
  184   3                  if(Circle_Flag3 == LEFT_CIRCLE)             //用来记录出环时的方向
  185   3                      Ratio -= 0.085;
  186   3                  else if(Circle_Flag3 == RIGHT_CIRCLE)
  187   3                      Ratio += 0.075;
  188   3                      
  189   3              }
C251 COMPILER V5.60.0,  Element                                                            20/07/24  17:24:57  PAGE 4   

  190   2              Circle_Delay2--;
  191   2                      return ;                                                //退出函数
  192   2              }
  193   1      
  194   1              if(Circle_Flag1 == 1)                                       //识别到环岛
  195   1              {
  196   2              Exp_Speed = 240;
  197   2             Gyro_Z = (Gyro_Z*2000)/32768;       
  198   2                      if(Sum_Dis1 > DIS_ROUND_IN)                         //路程积分，积满进环
  199   2                      {
  200   3                              Sum_Angle_C1 += Gyro_Z * 0.005;     //进环开始角度积分
  201   3                  //标志位未清零时只置位一次，防止重复识别
  202   3                              if(Circle_Flag2 == 0 && (ADC_proc[1]+ ADC_proc[0] >= ADC_proc[3]+ADC_proc[4]))
  203   3                              {
  204   4                                      Circle_Flag2 = LEFT_CIRCLE;     //判为左环岛
  205   4                                      x10_ms = 13;
  206   4                              }
  207   3                              else if(Circle_Flag2 == 0 && (ADC_proc[1]+ ADC_proc[0] < ADC_proc[3]+ADC_proc[4]))
  208   3                              {
  209   4                                      Circle_Flag2 = RIGHT_CIRCLE;
  210   4                                      x10_ms = 13;
  211   4                              }
  212   3                              
  213   3                              Circle_Flag3 = Circle_Flag2;            //临时变量记录方向
  214   3                              
  215   3                              if(Sum_Angle_C1 < 24 && Circle_Flag2 == LEFT_CIRCLE )   //角度未积满，固定偏差值
  216   3                              {
  217   4                      Ratio = 0.34;  
  218   4                  }
  219   3                              else if(Sum_Angle_C1 > -24 && Circle_Flag2 == RIGHT_CIRCLE)
  220   3                              {
  221   4                      Ratio = -0.34;
  222   4                  }
  223   3                      }
  224   2                      else
  225   2                              Sum_Dis1 += Speed;
  226   2                      
  227   2                      if(Sum_Angle_C1 > ROUND_L || Sum_Angle_C1 < ROUND_R )              //出环条件之一，角度积分够
             -大
  228   2                      {
  229   3                              if(ADC_proc[0] > 61 || ADC_proc[4] > 61 || ADC_proc[2] > 64)   //预出环 防止误判再次入环
  230   3                              {
  231   4                      Circle_Delay2 = 85;   //延时1400ms
  232   4                                      Sum_Dis1 = 0;
  233   4                                      Sum_Angle_C1 = 0;
  234   4                      Circle_Flag1 = 0;
  235   4                                      Circle_Flag2 = 0;
  236   4                      if(Elem_Over == 0)
  237   4                      {
  238   5                          Elem_Over = 1;
  239   5                          Special_Elem++;
  240   5                      }
  241   4                              }
  242   3                      }
  243   2              }
  244   1              else
  245   1              {
  246   2                      Sum_Dis1 = 0;
  247   2                      Sum_Angle_C1 = 0;
  248   2                      Circle_Flag2 = 0;
  249   2              }
  250   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       846     ------
C251 COMPILER V5.60.0,  Element                                                            20/07/24  17:24:57  PAGE 5   

  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        37     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        95     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
